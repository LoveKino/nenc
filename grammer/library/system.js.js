module.exports = "/**\n * provide basic function support for pfc middle code\n */\n\n/**************************************************************\n * basic data container\n **************************************************************/\n\nvar Void = {};\n\nvar isVoid = function(v) {\n    return v === Void;\n};\n\nfunction Pair(v1, v2) {\n    this.v1 = v1;\n    this.v2 = v2;\n}\n\nPair.prototype.getValueList = function() {\n    let result = [];\n    if (isPair(this.v1)) {\n        result = this.v1.getValueList();\n    } else {\n        result = [this.v1];\n    }\n\n    if (isPair(this.v2)) {\n        result = result.concat(this.v2.getValueList());\n    } else {\n        result.push(this.v2);\n    }\n\n    return result;\n};\n\nvar isPair = function(v) {\n    return v instanceof Pair;\n};\n\nvar Variable = function(variableName) {\n    this.variableName = variableName;\n};\n\nvar isVarible = function(v) {\n    return v instanceof Variable;\n};\n\nvar Abstraction = function(variables, bodyExp, context) {\n    // TODO check, avoid repeated variable names\n    this.variables = variables;\n    this.bodyExp = bodyExp;\n    this.context = context || null;\n\n    this.fillMap = {};\n    this.indexMap = {};\n    this.fillCount = 0;\n};\n\n/**\n * fill param value at specific position\n */\nvar fillAbstractionVariable = function(abstraction, index, value) {\n    abstraction.fillMap[index] = value;\n    if (!abstraction.indexMap[index]) {\n        abstraction.indexMap[index] = true;\n        abstraction.fillCount++;\n    }\n};\n\n/**\n * when all variables are assigned, this abstraction will become reducible\n */\nvar isAbstractionReducible = function(abstraction) {\n    return abstraction.variables.length <= abstraction.fillCount;\n};\n\nvar isAbstraction = function(v) {\n    return v instanceof Abstraction;\n};\n\nvar Application = function(caller, params) {\n    this.caller = caller;\n    this.params = params;\n};\n\nvar isApplication = function(v) {\n    return v instanceof Application;\n};\n\nvar MetaMethod = function(method) {\n    this.method = method;\n};\n\nvar isMetaMethod = function(v) {\n    return v instanceof MetaMethod;\n};\n\n/****************************************************\n * run program\n *****************************************************/\nvar sys_runProgram = function(program) {\n    return runProgram(program, new Context(defaultContextMap, null));\n};\n\n// TODO system methods\nvar defaultContextMap = {\n    '+': new MetaMethod(function(v1, v2) {\n        return v1 + v2;\n    })\n};\n\nvar runProgram = function(program, ctx) {\n    if (isVarible(program)) {\n        return lookupVariable(ctx, program.variableName);\n    } else if (isAbstraction(program)) {\n        program.context = ctx;\n        return program;\n    } else if (isApplication(program)) {\n        return runApplication(program, ctx);\n    } else { // source data\n        return program;\n    }\n};\n\nvar Context = function(variableMap, parent) {\n    this.parent = parent;\n    this.variableMap = variableMap;\n};\n\nvar runApplication = function(application, ctx) {\n    var callerRet = runProgram(application.caller, ctx);\n\n    // TODO system methods\n    if (!isAbstraction(callerRet) &&\n        !isMetaMethod(callerRet)\n    ) {\n        throw new Error('Expect function to run application, but got ' + callerRet);\n    }\n\n    var paramsRet = [];\n    var params = application.params;\n    var len = params.length;\n    for (var i = 0; i < len; i++) {\n        paramsRet.push(runProgram(params[i], ctx));\n    }\n\n    // run abstraction\n    if (isAbstraction(callerRet)) {\n        return runAbstraction(callerRet, paramsRet);\n    } else { // meta method\n        return runMetaMethod(callerRet, paramsRet);\n    }\n};\n\nvar runMetaMethod = function(metaMethod, paramsRet) {\n    return metaMethod.method.apply(undefined, paramsRet);\n};\n\nvar runAbstraction = function(source, paramsRet) {\n    // create a new abstraction\n    var abstraction = new Abstraction(source.variables, source.bodyExp, source.context);\n    // fill with some params\n    for (var i = 0; i < paramsRet.length; i++) {\n        fillAbstractionVariable(abstraction, i, paramsRet[i]);\n    }\n\n    if (isAbstractionReducible(abstraction)) {\n        // take out all variables\n        var variables = abstraction.variables;\n        var fillMap = abstraction.fillMap;\n        var variableMap = {};\n        for (var j = 0; j < variables.length; j++) {\n            var variableName = variables[j].variableName;\n            variableMap[variableName] = fillMap[j];\n        }\n        // attach variables to context\n        var newCtx = new Context(variableMap, source.context);\n        // run body expression with new context\n        return runProgram(abstraction.bodyExp, newCtx);\n    }\n    return abstraction;\n};\n\nvar lookupVariable = function(ctx, variableName) {\n    var variableMap = ctx.variableMap;\n    // lookup variable map\n    var value = variableMap[variableName];\n    if (value !== undefined) {\n        return value;\n    } else {\n        if (!ctx.parent) {\n            throw new Error('Missing definition for variable ' + variableName);\n        } else {\n            return lookupVariable(ctx.parent, variableName);\n        }\n    }\n};\n\n/**************************************************************\n * main interfaces\n **************************************************************/\n\nvar sys_application = function(caller, rest) {\n    var params = [];\n    if (!isVoid(rest)) {\n        if (isPair(rest)) {\n            params = rest.getValueList();\n        } else {\n            params = [rest];\n        }\n    }\n    return new Application(caller, params);\n};\n\nvar sys_variable = function(varName) {\n    return new Variable(varName);\n};\n\nvar sys_abstraction = function(params, body) {\n    var variables = [];\n    if (!isVoid(params)) {\n        variables = params.getValueList();\n    }\n    return new Abstraction(variables, body);\n};\n\nvar sys_void = function() {\n    return Void;\n};\n\nvar sys_pair = function(v1, v2) {\n    return new Pair(v1, v2);\n};\n\n// composed data types\nvar sys_object = function(v) {\n    if (isVoid(v)) return {};\n    // get list of values\n    // join to map\n    var result = {};\n    var list = v.getValueList();\n    var i = 0,\n        len = list.length;\n    while (i < len) {\n        var key = list[i];\n        var value = list[i + 1];\n        result[key] = value;\n        i += 2;\n    }\n\n    return result;\n};\n\nvar sys_array = function(v) {\n    if (isVoid(v)) return [];\n    // get list of values\n    // join to list\n    return v.getValueList();\n};\n\n// basic data types\nvar sys_string = function(str) {\n    return str;\n};\n\nvar sys_number = function(numberStr) {\n    return Number(numberStr);\n};\n\nvar sys_true = function() {\n    return true;\n};\n\nvar sys_false = function() {\n    return false;\n};\n\nvar sys_null = function() {\n    return null;\n};\n\nvar result = {\n    sys_void,\n    sys_pair,\n\n    sys_variable,\n    sys_abstraction,\n    sys_application,\n\n    sys_string,\n    sys_number,\n    sys_true,\n    sys_false,\n    sys_null,\n    sys_object,\n    sys_array,\n\n    sys_runProgram\n};\n\nif (typeof module === 'object' && module) {\n    module.exports = result;\n}\n\nreturn result;\n"