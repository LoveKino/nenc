module.exports = "/**\n * provide basic function support for pfc middle code\n */\n\n/**************************************************************\n * basic host language interfaces\n **************************************************************/\nvar concat = function(arr1, arr2) {\n    return arr1.concat(arr2);\n};\n\nvar push = function(arr, v) {\n    arr.push(v);\n    return arr;\n};\n\nvar applyMethod = function(method, params) {\n    return method.apply(undefined, params);\n};\n\n/**************************************************************\n * basic data container\n *\n * {\n *    type: '',\n *    content: {}\n * }\n *\n **************************************************************/\nvar PAIR = 'pair',\n    VOID = 'void',\n    DATA = 'data',\n    META_METHOD = 'metaMethod',\n    APPLICATION = 'application',\n    ABSTRACTION = 'abstraction',\n    VARIABLE = 'variable';\n\nvar isType = function(v, type) {\n    return v.type === type;\n};\n\nvar Void = {\n    type: VOID\n};\n\nfunction Pair(v1, v2) {\n    return {\n        type: PAIR,\n        content: {\n            v1, v2\n        }\n    };\n}\n\nfunction Variable(variableName) {\n    return {\n        type: VARIABLE,\n        content: {\n            variableName\n        }\n    };\n}\n\nfunction Abstraction(variables, bodyExp, context) {\n    // TODO check, avoid repeated variable names\n    return {\n        type: ABSTRACTION,\n        content: {\n            fillMap: {},\n            context: context || null,\n            variables,\n            bodyExp,\n            indexMap: {},\n            fillCount: 0\n        }\n    };\n}\n\nfunction Application(caller, params) {\n    return {\n        type: APPLICATION,\n        content: {\n            caller,\n            params\n        }\n    };\n}\n\nfunction MetaMethod(method) {\n    return {\n        type: META_METHOD,\n        content: {\n            method\n        }\n    };\n}\n\nfunction Data(data) {\n    return {\n        type: DATA,\n        content: {\n            data\n        }\n    };\n}\n\nfunction Context(variableMap, parent) {\n    this.parent = parent;\n    this.variableMap = variableMap;\n}\n\nvar getPairValueList = function(pair) {\n    var result = [];\n    if (isType(pair.content.v1, PAIR)) {\n        result = getPairValueList(pair.content.v1);\n    } else {\n        result = [pair.content.v1];\n    }\n\n    if (isType(pair.content.v2, PAIR)) {\n        result = concat(result, getPairValueList(pair.content.v2));\n    } else {\n        result = push(result, pair.content.v2);\n    }\n\n    return result;\n};\n\n/**\n * fill param value at specific position\n */\nvar fillAbstractionVariable = function(abstraction, index, value) {\n    abstraction.content.fillMap[index] = value;\n    if (!abstraction.content.indexMap[index]) {\n        abstraction.content.indexMap[index] = true;\n        abstraction.content.fillCount++;\n    }\n};\n\n/**\n * when all variables are assigned, this abstraction will become reducible\n */\nvar isAbstractionReducible = function(abstraction) {\n    return abstraction.content.variables.length <= abstraction.content.fillCount;\n};\n\nvar lookupVariable = function(ctx, variableName) {\n    var variableMap = ctx.variableMap;\n    // lookup variable map\n    var value = variableMap[variableName];\n    if (value !== undefined) {\n        return value;\n    } else {\n        if (!ctx.parent) {\n            throw new Error('Missing definition for variable ' + variableName);\n        } else {\n            return lookupVariable(ctx.parent, variableName);\n        }\n    }\n};\n\n/****************************************************\n * run program\n *****************************************************/\nvar runProgram = function(program, ctx) {\n    if (isType(program, VARIABLE)) {\n        return lookupVariable(ctx, program.content.variableName);\n    } else if (isType(program, ABSTRACTION)) {\n        program.content.context = ctx;\n        return program;\n    } else if (isType(program, APPLICATION)) {\n        return runApplication(program, ctx);\n    } else if (isType(program, DATA)) {\n        return program.content.data;\n    } else {\n        throw new Error('impossible situation');\n    }\n};\n\nvar runApplication = function(application, ctx) {\n    var callerRet = runProgram(application.content.caller, ctx);\n\n    // TODO system methods\n    if (!isType(callerRet, ABSTRACTION) &&\n        !isType(callerRet, META_METHOD)\n    ) {\n        throw new Error('Expect function to run application, but got ' + callerRet);\n    }\n\n    var paramsRet = [];\n    var params = application.content.params;\n    var len = params.length;\n    for (var i = 0; i < len; i++) {\n        paramsRet.push(runProgram(params[i], ctx));\n    }\n\n    // run abstraction\n    if (isType(callerRet, ABSTRACTION)) {\n        return runAbstraction(callerRet, paramsRet);\n    } else { // meta method\n        return runMetaMethod(callerRet, paramsRet);\n    }\n};\n\nvar runMetaMethod = function(metaMethod, paramsRet) {\n    // TODO check some restraints\n    return applyMethod(metaMethod.content.method, paramsRet);\n};\n\nvar runAbstraction = function(source, paramsRet) {\n    // create a new abstraction\n    var abstraction = Abstraction(source.content.variables, source.content.bodyExp, source.content.context);\n    // fill with some params\n    for (var i = 0; i < paramsRet.length; i++) {\n        fillAbstractionVariable(abstraction, i, paramsRet[i]);\n    }\n\n    if (isAbstractionReducible(abstraction)) {\n        // take out all variables\n        var variables = abstraction.content.variables;\n        var fillMap = abstraction.content.fillMap;\n        var variableMap = {};\n        for (var j = 0; j < variables.length; j++) {\n            var variableName = variables[j].content.variableName;\n            variableMap[variableName] = fillMap[j];\n        }\n        // attach variables to context\n        var newCtx = new Context(variableMap, source.content.context);\n        // run body expression with new context\n        return runProgram(abstraction.content.bodyExp, newCtx);\n    }\n    return abstraction;\n};\n\n/**************************************************************\n * main interfaces\n **************************************************************/\n// TODO system methods\nvar defaultContextMap = {\n    '+': MetaMethod(function(v1, v2) {\n        return v1 + v2;\n    }),\n\n    '-': MetaMethod(function(v1, v2) {\n        return v1 - v2;\n    }),\n\n    '*': MetaMethod(function(v1, v2) {\n        return v1 * v2;\n    }),\n\n    '/': MetaMethod(function(v1, v2) {\n        return v1 / v2;\n    })\n};\n\nvar sys_runProgram = function(program) {\n    return runProgram(program, new Context(defaultContextMap, null));\n};\n\nvar sys_application = function(caller, rest) {\n    var params = [];\n    if (!isType(rest, VOID)) {\n        if (isType(rest, PAIR)) {\n            params = getPairValueList(rest);\n        } else {\n            params = [rest];\n        }\n    }\n    return Application(caller, params);\n};\n\nvar sys_variable = function(varName) {\n    return Variable(varName);\n};\n\nvar sys_abstraction = function(params, body) {\n    var variables = [];\n    if (!isType(params, VOID)) {\n        if (isType(params, VARIABLE)) {\n            variables = [params];\n        } else {\n            variables = getPairValueList(params);\n        }\n    }\n    return Abstraction(variables, body);\n};\n\nvar sys_void = function() {\n    return Void;\n};\n\nvar sys_pair = function(v1, v2) {\n    return Pair(v1, v2);\n};\n\nvar sys_data = function(v) {\n    return Data(v);\n};\n\n// composed data types\nvar sys_object = function(v) {\n    if (isType(v, VOID)) return {};\n    // get list of values\n    // join to map\n    var result = {};\n    var list = getPairValueList(v);\n    var i = 0,\n        len = list.length;\n    while (i < len) {\n        var key = list[i];\n        var value = list[i + 1];\n        result[key] = value;\n        i += 2;\n    }\n\n    return result;\n};\n\nvar sys_array = function(v) {\n    if (isType(v, VOID)) return [];\n    // get list of values\n    // join to list\n    return getPairValueList(v);\n};\n\n// basic data types\nvar sys_string = function(str) {\n    return str;\n};\n\nvar sys_number = function(numberStr) {\n    return Number(numberStr);\n};\n\nvar sys_true = function() {\n    return true;\n};\n\nvar sys_false = function() {\n    return false;\n};\n\nvar sys_null = function() {\n    return null;\n};\n\nvar result = {\n    sys_void,\n    sys_pair,\n\n    sys_variable,\n    sys_abstraction,\n    sys_application,\n\n    sys_data,\n    sys_object,\n    sys_array,\n    sys_string,\n    sys_number,\n    sys_true,\n    sys_false,\n    sys_null,\n\n    sys_runProgram\n};\n\nif (typeof module === 'object' && module) {\n    module.exports = result;\n}\n\nreturn result;\n"